import{u as h,o as f,b as x}from"./index.f76e180b.js";const g=`uniform samplerCube u_cubeMap;
    in vec3 v_texCoord;
    out vec4 fragColor;
    void main(){
        vec4 color = textureCube(u_cubeMap, normalize(v_texCoord));
        fragColor = vec4(czm_gammaCorrect(color).rgb, czm_morphTime);
    }
`,_=`
    out vec3 position;
    in vec3 v_texCoord;
    uniform mat3 u_rotateMatrix;
    void main(){
        vec3 p = czm_viewRotation * u_rotateMatrix * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));
        gl_Position = czm_projection * vec4(p, 1.0);
        v_texCoord = position.xyz;
    }
`,u=Cesium.BoxGeometry,y=Cesium.Cartesian3,C=Cesium.defaultValue,s=Cesium.defined,v=Cesium.destroyObject,m=Cesium.DeveloperError,b=Cesium.GeometryPipeline,M=Cesium.Matrix3,c=Cesium.Matrix4,l=Cesium.Transforms,S=Cesium.VertexFormat,B=Cesium.BufferUsage,k=Cesium.CubeMap,w=Cesium.DrawCommand,P=Cesium.loadCubeMap,A=Cesium.RenderState,X=Cesium.VertexArray,D=Cesium.BlendingState,d=Cesium.SceneMode,L=Cesium.ShaderProgram,z=Cesium.ShaderSource,Y=new M;Cesium.defined(Cesium.Matrix4.getRotation)||(Cesium.Matrix4.getRotation=Cesium.Matrix4.getMatrix3);class R{constructor(e){this.sources=e.sources,this._sources=void 0,this.show=C(e.show,!0),this._command=new w({modelMatrix:c.clone(c.IDENTITY),owner:this}),this._cubeMap=void 0,this._attributeLocations=void 0,this._useHdr=void 0}update(e,i){const r=this;if(!this.show||e.mode!==d.SCENE3D&&e.mode!==d.MORPHING||!e.passes.render)return;const n=e.context;if(this._sources!==this.sources){this._sources=this.sources;const t=this.sources;if(!s(t.positiveX)||!s(t.negativeX)||!s(t.positiveY)||!s(t.negativeY)||!s(t.positiveZ)||!s(t.negativeZ))throw new m("this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.");if(typeof t.positiveX!=typeof t.negativeX||typeof t.positiveX!=typeof t.positiveY||typeof t.positiveX!=typeof t.negativeY||typeof t.positiveX!=typeof t.positiveZ||typeof t.positiveX!=typeof t.negativeZ)throw new m("this.sources properties must all be the same type.");typeof t.positiveX=="string"?P(n,this._sources).then(function(a){r._cubeMap=r._cubeMap&&r._cubeMap.destroy(),r._cubeMap=a}):(this._cubeMap=this._cubeMap&&this._cubeMap.destroy(),this._cubeMap=new k({context:n,source:t}))}const o=this._command;if(o.modelMatrix=l.eastNorthUpToFixedFrame(e.camera._positionWC),!s(o.vertexArray)){o.uniformMap={u_cubeMap:function(){return r._cubeMap},u_rotateMatrix:function(){return c.getRotation(o.modelMatrix,Y)}};const t=u.createGeometry(u.fromDimensions({dimensions:new y(2,2,2),vertexFormat:S.POSITION_ONLY})),a=this._attributeLocations=b.createAttributeLocations(t);o.vertexArray=X.fromGeometry({context:n,geometry:t,attributeLocations:a,bufferUsage:B._DRAW}),o.renderState=A.fromCache({blending:D.ALPHA_BLEND})}if(!s(o.shaderProgram)||this._useHdr!==i){const t=new z({defines:[i?"HDR":""],sources:[g]});o.shaderProgram=L.fromCache({context:n,vertexShaderSource:_,fragmentShaderSource:t,attributeLocations:this._attributeLocations}),this._useHdr=i}if(!!s(this._cubeMap))return o}setSkyBox(e){let i=e.scene.skyBox;e.scene.preUpdate.addEventListener(()=>{let r=e.scene.camera.position;Cesium.Cartographic.fromCartesian(r).height<24e4?(e.scene.skyBox=this,e.scene.skyAtmosphere.show=!1):(e.scene.skyBox=i,e.scene.skyAtmosphere.show=!0)})}isDestroyed(){return!1}destroy(){const e=this._command;return e.vertexArray=e.vertexArray&&e.vertexArray.destroy(),e.shaderProgram=e.shaderProgram&&e.shaderProgram.destroy(),this._cubeMap=this._cubeMap&&this._cubeMap.destroy(),v(this)}}const F={__name:"skybox",setup(p){const e=h(),{viewer:i}=e.state;return new R({sources:{positiveX:"/images/Standard-Cube-Map/px1.png",negativeX:"/images/Standard-Cube-Map/nx1.png",positiveY:"/images/Standard-Cube-Map/pz.png",negativeY:"/images/Standard-Cube-Map/nz1.png",positiveZ:"/images/Standard-Cube-Map/py.png",negativeZ:"/images/Standard-Cube-Map/ny1.png"}}).setSkyBox(i),(n,o)=>(f(),x("div"))}};export{F as default};
